# Progress Log

## Learnings
(Patterns discovered during implementation)
- Use `npm create vite@latest temp-folder -- --template react-ts` to avoid non-empty directory issues, then copy files
- Vite template comes with ESLint pre-configured, just need to add eslint-config-prettier
- Add safe.directory to git config on Windows for network drives: `git config --global --add safe.directory <path>`
- Don't use useEffect to setState from props - display prop value directly when not editing
- Don't use refs during render (e.g. prevValueRef.current in conditionals) - ESLint strict mode disallows this

---

## Iteration 1 - US-001: Initialize project with Vite + React + TypeScript
- What was implemented:
  - Vite project with React 19 + TypeScript template
  - ESLint configuration with TypeScript, React hooks, React refresh plugins
  - Prettier configuration (.prettierrc)
  - Folder structure: src/components, src/hooks, src/stores, src/utils, src/types
  - Added typecheck and format npm scripts
- Files changed:
  - package.json (created, modified name/version/scripts)
  - eslint.config.js (created, modified to add prettier)
  - .prettierrc (created)
  - .gitignore (created)
  - All Vite template files
  - src/ folder structure with .gitkeep files
- Learnings for future iterations:
  - Typecheck command: `npm run typecheck`
  - Lint command: `npm run lint`
  - Dev server: `npm run dev` (runs on localhost:5173)
---

## Iteration 2 - US-002: Create app shell with layout structure
- What was implemented:
  - Flexbox-based layout with TopBar, Toolbar, Canvas, PropertiesPanel, StatusBar
  - Dark theme with CSS variables (--color-bg-primary: #1a1a1a, --color-bg-secondary: #2a2a2a)
  - Layout components in src/components/layout/
  - Collapsible properties panel with toggle button
  - Status bar with placeholder position and selection display
- Files changed:
  - src/index.css (global styles + CSS variables)
  - src/App.css (main layout)
  - src/App.tsx (component composition)
  - src/components/layout/Toolbar.tsx + .css
  - src/components/layout/TopBar.tsx + .css
  - src/components/layout/PropertiesPanel.tsx + .css
  - src/components/layout/Canvas.tsx + .css
  - src/components/layout/StatusBar.tsx + .css
  - src/components/layout/index.ts (barrel export)
- Learnings for future iterations:
  - Layout uses CSS variables for dimensions: --toolbar-width, --topbar-height, etc.
  - Components are organized in src/components/layout/
  - Use barrel exports (index.ts) for cleaner imports
---

## Iteration 3 - US-003: Implement canvas with pan and zoom
- What was implemented:
  - HTML Canvas element with 2D context, fills container and handles window resize
  - Device pixel ratio (DPR) scaling for crisp rendering on high-DPI displays
  - Mouse wheel zoom centered on cursor position (10% to 500% range)
  - Middle-mouse button drag for panning
  - Space+left-click drag for panning (alternative method)
  - Dot grid pattern that scales with zoom and moves with pan
  - Cursor changes to grab/grabbing during pan operations
- Files changed:
  - src/components/layout/Canvas.tsx (complete rewrite with pan/zoom logic)
  - src/components/layout/Canvas.css (added .canvas class styles)
- Learnings for future iterations:
  - Viewport state: { x, y, zoom } where x/y are pan offsets in canvas coords
  - Canvas uses requestAnimationFrame-compatible draw() callback
  - Use useCallback for handlers to prevent unnecessary re-renders
  - Window keydown/keyup listeners for Space key pan mode
  - Grid offset calculation: (panOffset * zoom) % gridSpacing for seamless tiling
---

## Iteration 4 - US-004: Create Zustand store for canvas state
- What was implemented:
  - Installed Zustand package for state management
  - Created TypeScript interfaces in src/types/canvas.ts for all canvas object types
  - Created Zustand store in src/stores/canvasStore.ts with:
    - State: objects (Map), selectedIds (Set), viewport
    - Actions: addObject, updateObject, deleteObject, setSelection, setViewport
  - All object types extend BaseObject with id, type, x, y, width, height, rotation, opacity
- Files changed:
  - package.json (added zustand dependency)
  - src/types/canvas.ts (created - object type definitions)
  - src/stores/canvasStore.ts (created - Zustand store)
- Learnings for future iterations:
  - Store import: `import { useCanvasStore } from '../stores/canvasStore'`
  - Types import: `import type { CanvasObject, Viewport } from '../types/canvas'`
  - Using Map and Set for objects/selectedIds for O(1) lookups
  - Object types: rectangle, ellipse, text, frame, path, image, video
  - Tool types: select, hand, rectangle, text, frame, pen
---

## Iteration 5 - US-005: Build left toolbar with tool buttons
- What was implemented:
  - Added activeTool state and setActiveTool action to Zustand store
  - Vertical toolbar with 6 tool buttons: Select (V), Hand (H), Rectangle (R), Text (T), Frame (F), Pen (P)
  - Each button has a custom SVG icon
  - Active tool highlighted with accent color (--color-accent: #0066ff)
  - Tooltips on hover showing tool name + keyboard shortcut
  - Divider line after Text tool to separate tool groups
- Files changed:
  - src/stores/canvasStore.ts (added activeTool state and setActiveTool action)
  - src/components/layout/Toolbar.tsx (added tool buttons with icons)
  - src/components/layout/Toolbar.css (added styles for buttons, active state, tooltips, divider)
- Learnings for future iterations:
  - Tool buttons use position: relative with tooltip positioned absolutely to the right
  - Tooltip appears on hover with opacity transition
  - Store state selector: `useCanvasStore((state) => state.activeTool)`
  - setActiveTool can be called with ToolType to switch tools
---

## Iteration 6 - US-006: Implement tool state and keyboard shortcuts
- What was implemented:
  - Created useKeyboardShortcuts hook in src/hooks/useKeyboardShortcuts.ts
  - Global keyboard event listener for tool switching shortcuts
  - Shortcuts: V (select), H (hand), R (rectangle), T (text), F (frame), P (pen)
  - Shortcuts disabled when typing in input fields, textareas, or contenteditable elements
  - Shortcuts also disabled when modifier keys (Ctrl/Meta/Alt) are pressed
  - Wired up hook in App.tsx to enable shortcuts globally
- Files changed:
  - src/hooks/useKeyboardShortcuts.ts (created)
  - src/App.tsx (added hook import and call)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Check target.tagName for INPUT/TEXTAREA and target.isContentEditable to disable shortcuts
  - Use window.addEventListener for global keyboard shortcuts
  - Remember to clean up listeners in useEffect return
---

## Iteration 7 - US-007: Implement selection tool with click-to-select
- What was implemented:
  - Hit testing function to detect clicks on objects (with rotation support)
  - Click on object selects it (updates selectedIds in store)
  - Click on empty canvas deselects all
  - Selection box with 8 resize handles + rotation handle
  - Selection highlight color: blue (#0066ff)
  - Shift+click toggles selection (add/remove from selection)
  - Coordinate conversion helpers: canvasToScreen, screenToCanvas
  - Object rendering for all types: rectangle, ellipse, text, frame, path
- Files changed:
  - src/components/layout/Canvas.tsx (added hitTest, drawObject, drawSelectionBox, selection handling)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Hit testing with rotation: translate point relative to object center, apply inverse rotation, then check bounds
  - Draw selection boxes after objects so they appear on top
  - Handle positions array pattern: corners and edge midpoints for 8 handles
  - Rotation handle: positioned above top-center with connecting line
  - Store selectors: use separate selectors to avoid unnecessary re-renders
---

## Iteration 8 - US-008: Implement selection tool drag-to-move
- What was implemented:
  - Added updateObjects batch action to store for efficient multi-object updates
  - Drag state tracking (isDragging, hoveredObjectId) in Canvas component
  - Drag-to-move for selected objects with real-time position updates
  - Multiple selected objects move together using batch updates
  - Hover detection for move cursor on selected objects
  - Added test objects in App.tsx for development testing
  - Fixed JSX.Element type to use ReactNode in Toolbar
- Files changed:
  - src/stores/canvasStore.ts (added updateObjects batch action)
  - src/components/layout/Canvas.tsx (added drag handling and hover detection)
  - src/components/layout/Toolbar.tsx (fixed JSX.Element type)
  - src/App.tsx (added test objects for development)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use batch updates (updateObjects) for moving multiple objects to avoid re-render overhead
  - Track drag state with refs (lastMousePos, dragStartCanvasPos) to avoid state update lag
  - Movement delta = (screen delta) / zoom for correct canvas coordinate translation
  - Cursor style logic: check isDragging first, then hoveredObjectId for hover state
---

## Iteration 9 - US-009: Implement marquee selection
- What was implemented:
  - Marquee selection state tracking (isMarqueeSelecting, marqueeStart, marqueeEnd refs)
  - Drag on empty canvas draws selection rectangle with dashed blue border and semi-transparent blue fill
  - Objects intersecting marquee rectangle are selected on mouse up (AABB intersection check)
  - Shift+drag adds to existing selection (preserves current selection)
  - Fixed ESLint error: added braces around case 'text' block for lexical declaration
- Files changed:
  - src/components/layout/Canvas.tsx (added marquee selection logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use refs (marqueeStart, marqueeEnd, marqueeShiftKey) for tracking marquee state during drag
  - AABB intersection check: !(obj.x > maxX || objRight < minX || obj.y > maxY || objBottom < minY)
  - Force redraw during marquee drag by calling draw() directly to show marquee rectangle
  - ctx.setLineDash([4, 4]) creates dashed border effect
  - Remember to handle mouseLeave to cancel marquee selection if mouse leaves canvas
---

## Iteration 10 - US-010: Implement resize via selection handles
- What was implemented:
  - HandleType type definition for 8 handle types (nw, n, ne, e, se, s, sw, w)
  - HANDLE_POSITIONS array with position getters for each handle
  - HANDLE_CURSORS map for appropriate resize cursors
  - hitTestHandle function to detect clicks on resize handles with rotation support
  - Resize logic for all 8 handles with proportional/free resize support
  - Corner handles: proportional resize by default, Shift for free resize
  - Edge handles: single dimension resize only
  - Minimum size enforcement (10x10px MIN_OBJECT_SIZE constant)
  - Cursor changes to resize cursors on handle hover
  - State: isResizing, activeResizeHandle, hoveredHandle
  - Refs: resizeHandle, resizeStartObjState, resizeShiftKey
- Files changed:
  - src/components/layout/Canvas.tsx (added resize handle types, hit testing, resize logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use state (activeResizeHandle) instead of ref for cursor style to avoid ESLint ref-during-render errors
  - Handle hit testing: transform click point to object's local coordinate system using inverse rotation
  - Resize proportionally: use aspect ratio and decide which dimension to follow based on larger delta
  - For handles that affect position (nw, n, ne, w, sw), recalculate x/y based on new dimensions
  - Enforce minimum size by clamping dimensions and recalculating position for affected handles
---

## Iteration 11 - US-011: Implement rotation via handle
- What was implemented:
  - RotationHandle type definition ('rotation' | null)
  - hitTestRotationHandle function to detect clicks on rotation handle
  - Rotation state tracking: isRotating, hoveredRotationHandle, rotationStartAngle, rotationObjStartRotation
  - Drag rotation handle rotates object around its center
  - Shift+drag snaps rotation to 15° increments
  - Cursor changes to 'grab' when hovering rotation handle
  - Rotation is calculated using Math.atan2 to get angle from object center to mouse position
- Files changed:
  - src/components/layout/Canvas.tsx (added rotation handle types, hit testing, rotation logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use Math.atan2(dy, dx) to calculate angle from center to mouse position
  - Add +90 offset because rotation handle is at top (not right side like 0° in atan2)
  - Track rotation start angle and object's starting rotation to calculate delta
  - Normalize rotation to 0-360 range: ((rotation % 360) + 360) % 360
  - Snap to increments: Math.round(value / increment) * increment
  - Check rotation handle hit test BEFORE resize handles since rotation handle is above object
---

## Iteration 12 - US-012: Implement rectangle tool
- What was implemented:
  - Rectangle tool drawing functionality in Canvas.tsx
  - State: isDrawingRect to track when user is drawing
  - Refs: rectDrawStart, rectDrawEnd, rectDrawShiftKey for tracking draw state
  - drawRectPreview function to show rectangle preview while drawing
  - On mouse down with rectangle tool: start drawing at click position
  - On mouse move: update preview, Shift constrains to square
  - On mouse up: create rectangle object with default fill (#4a4a4a), add to store
  - Tool automatically switches to Select after drawing
  - Minimum size check (10x10px) before creating rectangle
  - Uses crypto.randomUUID() for generating unique object IDs
- Files changed:
  - src/components/layout/Canvas.tsx (added rectangle tool logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Import RectangleObject type from types/canvas for typed object creation
  - Use refs for tracking draw start/end to avoid state update lag during drag
  - crypto.randomUUID() is built into modern browsers, no need for nanoid
  - Square constraint: Math.max(abs(width), abs(height)) for both dimensions with sign preserved
  - Normalize negative dimensions: x = width >= 0 ? start.x : start.x + width
  - Remember to add isDrawingRect to all relevant dependency arrays
---

## Iteration 13 - US-013: Implement ellipse shape variant
- What was implemented:
  - Alt+Rectangle tool draws ellipse instead of rectangle
  - Ellipse preview shown while drawing when Alt is held
  - Shift constrains to circle (both for preview and final shape)
  - Alt key is tracked during mouse down, move, and up events
  - EllipseObject type imported and used for ellipse creation
- Files changed:
  - src/components/layout/Canvas.tsx (added Alt key tracking and ellipse drawing logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use rectDrawAltKey ref to track Alt key state during drawing operation
  - Ellipse rendering uses ctx.ellipse() with center position and radii
  - Alt key can be toggled during drawing to switch between rectangle and ellipse preview
  - EllipseObject type already existed in canvas.ts, rendering was also already implemented
---

## Iteration 14 - US-014: Implement text tool
- What was implemented:
  - Click with Text tool creates text object at click position
  - Text object enters edit mode immediately with focused HTML input overlay
  - Typing updates text content in real-time via updateObject store action
  - Click outside (onBlur), Escape, or Enter exits edit mode
  - Default font: Inter/system-ui/sans-serif, 16px, white (#ffffff)
  - Tool switches to Select after creating text object
- Files changed:
  - src/components/layout/Canvas.tsx (added text tool handling, editingTextId state, text input overlay)
  - src/components/layout/Canvas.css (added .text-edit-input styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use HTML input overlay positioned absolutely over canvas for text editing
  - Calculate screen position using canvasToScreen and apply viewport.zoom to font size
  - Use e.stopPropagation() on text input keydown to prevent tool shortcuts firing
  - TextObject type already defined in canvas.ts with text, fontSize, fontFamily, textAlign
  - onBlur handles click outside, onKeyDown handles Escape/Enter
---

## Iteration 15 - US-015: Implement text editing on existing text
- What was implemented:
  - Double-click detection using lastClickTime and lastClickObjectId refs
  - 300ms threshold for double-click detection on same object
  - Double-click on text object enters edit mode and selects the object
  - Native HTML input handles cursor position tracking via selectionStart/selectionEnd
  - Arrow keys navigate cursor naturally via native input behavior
  - Shift+arrows, Ctrl+A, Home/End, and double-click word selection all work via native input
- Files changed:
  - src/components/layout/Canvas.tsx (added double-click detection refs and handling)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Double-click detection: track lastClickTime and lastClickObjectId, compare with 300ms threshold
  - Native HTML input elements handle cursor and selection naturally - no custom implementation needed
  - Return early from handleMouseDown after entering text edit mode to prevent starting drag
  - stopPropagation in handleTextKeyDown prevents tool shortcuts but allows native input behaviors
---

## Iteration 16 - US-016: Implement frame tool
- What was implemented:
  - Frame tool drawing functionality - drag on canvas creates frame object
  - Frame preview while drawing (showing background, border, and "Frame" label)
  - Frame object with subtle background (#2a2a2a) and border (#3a3a3a)
  - Frame label showing name above the frame
  - Frame name editable via double-click (similar to text editing)
  - Frame name input overlay positioned above frame
  - Cursor changes to crosshair when frame tool is active
- Files changed:
  - src/components/layout/Canvas.tsx (added frame drawing, preview, name editing)
  - src/components/layout/Canvas.css (added .frame-name-input styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Frame tool follows same pattern as rectangle tool for drawing
  - FrameObject type already existed in canvas.ts with name property
  - Frame rendering was already implemented in drawObject, just needed drawing logic
  - Double-click detection pattern reused from text editing for frame name editing
  - Input overlay positioned using top offset to appear above frame (top - fontSize - 4px)
---

## Iteration 17 - US-017: Implement pen tool for freehand drawing
- What was implemented:
  - Pen tool drawing functionality - drag creates path from mouse movement
  - State tracking: isDrawingPath (boolean), pathDrawPoints (ref to PathPoint[])
  - Mouse down with pen tool starts path with first point
  - Mouse move adds points to the path array while drawing
  - Mouse up finalizes path: calculates bounding box, normalizes points relative to top-left
  - drawPathPreview function renders path during drawing
  - Default stroke: white (#ffffff), 2px, round line caps and joins
  - Tool automatically switches to select after drawing
  - Crosshair cursor shown when pen tool is active
- Files changed:
  - src/components/layout/Canvas.tsx (added pen tool handling, path preview, state management)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - PathObject and PathPoint types already existed in canvas.ts
  - Path rendering was already implemented in drawObject, just needed drawing logic
  - Pattern: collect points relative to canvas, then normalize to bounding box on finalize
  - Path bounding box calculated by finding min/max x/y of all points
  - Points normalized by subtracting minX/minY from each point
  - Path object stores normalized points (relative to object's x,y position)
---

## Iteration 18 - US-018: Build properties panel structure
- What was implemented:
  - Panel header with "PROPERTIES" title and settings gear icon
  - CollapsibleSection component for reusable section pattern
  - PropertyRow component for label/value display
  - Transform section: X-POS, Y-POS, WIDTH, HEIGHT, ROTATION
  - Appearance section: OPACITY, FILL, STROKE
  - Hierarchy section: item count and object list with type icons
  - Empty state: shows "---" for all values when nothing selected
  - Hierarchy items highlight when selected
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (complete rewrite with sections)
  - src/components/layout/PropertiesPanel.css (added styles for all new elements)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - CollapsibleSection pattern: internal state for isOpen, toggle button, conditional content render
  - getDisplayValue pattern: function that checks selection state and calls getter only if valid
  - Hierarchy icons: use Unicode symbols (▢, ○, T, ⬚, ✎) for quick type identification
  - Type narrowing with 'text' in obj pattern for accessing type-specific properties
  - Next tasks (US-019 to US-024) will need editable inputs instead of read-only PropertyRow
---

## Iteration 19 - US-019: Implement transform section (position)
- What was implemented:
  - EditablePropertyRow component for editable numeric inputs
  - X-POS and Y-POS input fields that show current object position
  - Click to edit, Enter commits, Escape reverts
  - Values sync with canvas when object is moved
  - getMultiSelectValue function: shows "---" when multiple objects have different values
  - CSS styles for editable inputs with hover state
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added EditablePropertyRow, getMultiSelectValue, updateObject usage)
  - src/components/layout/PropertiesPanel.css (added .property-value.editable and .property-input styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - EditablePropertyRow pattern: useState for isEditing/editValue, useRef for input/originalValue
  - Track originalValue on edit start to support Escape revert
  - Use useEffect to sync editValue with prop when not editing
  - stopPropagation on keydown to prevent tool shortcuts from firing
  - getMultiSelectValue checks if all selected objects have same value
---

## Iteration 20 - US-020: Implement transform section (size)
- What was implemented:
  - Editable WIDTH and HEIGHT input fields in the Transform section
  - Values update when object is selected and sync with canvas
  - Typing in field updates object size (Enter commits, Escape reverts)
  - Constrain proportions toggle (chain link icon) that maintains aspect ratio
  - When constrain is ON: changing width proportionally updates height (and vice versa)
  - Fixed ESLint error by removing useEffect-based value sync
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added size-row wrapper, constrain toggle, updated WIDTH/HEIGHT to EditablePropertyRow)
  - src/components/layout/PropertiesPanel.css (added .size-row and .constrain-toggle styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Don't use useEffect to sync editValue with prop - just display prop value directly when not editing
  - Don't use refs during render - ESLint will error on prevValueRef.current comparisons
  - Constrain proportions pattern: calculate aspect ratio from current dimensions, multiply new value by ratio
  - SVG chain link icon: use paths for half-loops and optional connecting line for "linked" state
---

## Iteration 21 - US-021: Implement transform section (rotation)
- What was implemented:
  - RotationControl component with editable degree input field
  - Circular dial/slider for visual rotation adjustment
  - Value shows degrees (0-360) with normalization
  - Dragging dial rotates object in real-time
  - Click to edit input, Enter commits, Escape reverts
  - Shows "---" when nothing selected (disabled state)
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added RotationControl component with useCallback)
  - src/components/layout/PropertiesPanel.css (added .rotation-control, .rotation-dial styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Rotation dial: use atan2 to calculate angle from center to mouse, add 90 to offset 0° to top
  - Handle angle wrapping: if delta > 180, subtract 360; if < -180, add 360
  - Track dragStartAngle and dragStartValue to calculate delta rotation
  - Use window event listeners for mousemove/mouseup during drag
  - transform-origin: bottom center for rotating indicator from center
---

## Iteration 22 - US-022: Implement appearance section (opacity)
- What was implemented:
  - OpacityControl component with editable percentage input (0-100%)
  - Horizontal slider for visual opacity adjustment
  - Dragging slider updates object opacity in real-time
  - Click to edit input, Enter commits, Escape reverts
  - Clamps values to 0-100 range
  - Shows "---" when nothing selected (disabled state)
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added OpacityControl component)
  - src/components/layout/PropertiesPanel.css (added .opacity-control and .opacity-slider styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Slider pattern: track + fill + handle, calculate percentage from mouse X position
  - Opacity stored as 0-1 internally but displayed as 0-100%
  - Use getOpacityFromMouse with getBoundingClientRect for position calculation
  - Similar pattern to RotationControl but with linear slider instead of circular dial
  - Disable transitions during drag for instant feedback
---

## Iteration 23 - US-023: Implement appearance section (fill)
- What was implemented:
  - FillControl component with checkbox, color swatch, and hex input
  - Checkbox enables/disables fill (setting fill to undefined when disabled)
  - Color swatch button opens/closes color picker popup
  - Editable hex input with validation and normalization (3-digit and 6-digit hex)
  - ColorPicker component with HSV color model
  - Saturation/brightness square with white-to-transparent and black-to-transparent gradients
  - Horizontal hue slider with rainbow gradient (0-360 degrees)
  - Real-time color updates during drag operations
  - Helper functions: rgbToHsv, hsvToRgb, hexToRgb, rgbToHex
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added FillControl, ColorPicker, HSV/RGB conversion functions)
  - src/components/layout/PropertiesPanel.css (added .fill-control, .color-swatch, .color-picker styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - HSV color model: Hue (0-360), Saturation (0-100), Value/Brightness (0-100)
  - SV picker: background color = pure hue, white gradient left-to-right, black gradient bottom-to-top
  - Handle click-outside to close popups using document.addEventListener('mousedown')
  - Hex validation regex: /^#?([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/
  - 3-digit hex normalization: #abc -> #aabbcc
  - Fill toggle pattern: enabled = fill !== undefined, disable = set fill to undefined
---

## Iteration 24 - US-024: Implement appearance section (stroke)
- What was implemented:
  - StrokeControl component with checkbox to enable/disable stroke
  - Color swatch and editable hex input for stroke color
  - Stroke width input (px) with validation (minimum 1px)
  - Color picker reused from FillControl (ColorPicker component)
  - Real-time updates when changing stroke color or width
  - Stroke toggle: enable sets default #ffffff color and 2px width, disable sets both to undefined
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added StrokeControl component)
  - src/components/layout/PropertiesPanel.css (added .stroke-control, .stroke-row, .stroke-width-row styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - StrokeControl follows same pattern as FillControl but with additional width input
  - Reusing ColorPicker component: same HSV-based color picker works for both fill and stroke
  - Stroke width row indented with margin-left: 22px to align under the checkbox+label
  - Width validation: parseFloat + Math.max(1, Math.round(numValue)) ensures minimum 1px
---

## Iteration 25 - US-025: Implement hierarchy section
- What was implemented:
  - Added zIndex property to BaseObject interface for z-ordering
  - Added reorderObject action to canvasStore for drag-and-drop reordering
  - Added getNextZIndex action to canvasStore for assigning zIndex to new objects
  - Refactored HierarchySection into separate component with:
    - Click item to select object on canvas (updates selectedIds)
    - Shift+click and Ctrl+click for multi-selection
    - Drag-and-drop to reorder (changes z-index)
    - Visual feedback (blue line) for drag-over positions
    - Drag handle (⋮⋮) on each item
  - Updated Canvas to render objects sorted by zIndex (low to high)
  - Updated Canvas hit testing to check highest zIndex first
  - Updated all object creation to use getNextZIndex()
  - Removed unused PropertyRow component and getDisplayValue function
- Files changed:
  - src/types/canvas.ts (added zIndex to BaseObject)
  - src/stores/canvasStore.ts (added reorderObject and getNextZIndex actions)
  - src/components/layout/PropertiesPanel.tsx (added HierarchySection component)
  - src/components/layout/PropertiesPanel.css (added drag-and-drop styles)
  - src/components/layout/Canvas.tsx (sorted rendering, hit testing, zIndex assignment)
  - src/App.tsx (added zIndex to test objects)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use zIndex for z-ordering, highest zIndex renders on top
  - Hierarchy list shows highest zIndex at top (opposite of render order)
  - HTML5 drag-and-drop: onDragStart, onDragOver, onDrop, onDragEnd events
  - Calculate drop position (above/below) using midpoint of target element
  - reorderObject shifts other objects' zIndex values to make room
  - getNextZIndex finds max zIndex + 1 for new objects
---

## Iteration 26 - US-026: Build top bar with branding
- What was implemented:
  - Left section: App logo (blue square with V icon), "KARTA" text, version badge "V1.0.0"
  - Center section: Editable session/document name with click-to-edit
  - Right section: Connection status icon (green circle), user avatar (blue circle with initial)
  - Dark theme styling matching mockup aesthetic
  - Session name editing: click to edit, Enter/blur commits, Escape cancels
- Files changed:
  - src/components/layout/TopBar.tsx (added branding, session name editing, status icons)
  - src/components/layout/TopBar.css (added styles for branding, session name, connection status, avatar)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Session name editing follows same pattern as other editable inputs (EditablePropertyRow)
  - Use setTimeout(..., 0) to focus and select input after it's rendered
  - Connection status uses CSS classes (connected/disconnected) for color switching
  - Version badge styled as small pill with tertiary background
---

## Iteration 27 - US-027: Build bottom status bar
- What was implemented:
  - Added cursorPosition state to canvasStore (null when mouse not over canvas)
  - Added setCursorPosition action to update cursor position
  - StatusBar reads cursor position and selection count from store
  - Real-time updates as mouse moves over canvas
  - Shows canvas coordinates accounting for pan/zoom via screenToCanvas conversion
  - Selection display: "SEL NONE" / "SEL 1 object" / "SEL X objects"
- Files changed:
  - src/stores/canvasStore.ts (added cursorPosition state and setCursorPosition action)
  - src/components/layout/Canvas.tsx (update cursor position on mouse move, clear on mouse leave)
  - src/components/layout/StatusBar.tsx (read from store, format display)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use Zustand store to share state between sibling components (Canvas and StatusBar)
  - screenToCanvas already accounts for pan/zoom, returns correct canvas coordinates
  - Set cursor position to null on mouse leave to show "---" placeholder
  - Math.round() for clean integer display of coordinates
---

## Iteration 28 - US-028: Implement zoom controls
- What was implemented:
  - Zoom buttons (+ and -) in bottom-right of status bar
  - Zoom percentage display between buttons (shows current zoom level)
  - + button increases zoom by 25% (multiply by 1.25)
  - - button decreases zoom by 25% (divide by 1.25)
  - Zoom clamped to 10%-500% range (0.1 to 5.0)
  - Keyboard shortcuts: Ctrl+= (zoom in), Ctrl+- (zoom out), Ctrl+0 (reset to 100%)
  - Shortcuts work globally except when in input fields
- Files changed:
  - src/components/layout/StatusBar.tsx (added zoom controls UI and handlers)
  - src/components/layout/StatusBar.css (added zoom button styles, restructured layout)
  - src/hooks/useKeyboardShortcuts.ts (added Ctrl+=/Ctrl+-/Ctrl+0 zoom shortcuts)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - StatusBar now has three sections: left (position), center (selection), right (zoom)
  - Zoom multiplier of 1.25 gives nice 25% increments
  - Handle both '=' and '+' for zoom in (keyboard layouts differ)
  - useCanvasStore.getState() can be used inside event handler to get current state
---

## Iteration 29 - US-029: Implement image import via file picker
- What was implemented:
  - Import Image button added to toolbar (below pen tool, after divider)
  - Hidden file input accepting .png, .jpg, .gif, .webp formats
  - FileReader reads image as data URL, Image object loads dimensions
  - Images placed at canvas center accounting for viewport pan/zoom
  - Large images scaled down to max 800px while maintaining aspect ratio
  - Canvas now properly renders images instead of placeholder
  - Image cache (Map<string, HTMLImageElement>) for performance
  - imageLoadTrigger state to trigger redraws when images finish loading
- Files changed:
  - src/components/layout/Toolbar.tsx (added import button, file input, file handling logic)
  - src/components/layout/Canvas.tsx (added ImageObject import, imageCache, image rendering logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use data URLs (FileReader.readAsDataURL) for image storage in objects
  - Image cache outside component avoids reloading on every render
  - Use state trigger (imageLoadTrigger) to force redraw when async image loads
  - Check img.complete && img.naturalWidth > 0 to verify image is fully loaded
  - Calculate canvas center: -viewport.x + (window.innerWidth / 2) / viewport.zoom
  - Reset file input value after reading to allow re-selecting same file
---

## Iteration 30 - US-030: Implement image drag-and-drop
- What was implemented:
  - isDragOver state to track when files are being dragged over canvas
  - handleDragOver, handleDragEnter, handleDragLeave event handlers
  - handleDrop event handler for processing dropped image files
  - Drop indicator overlay with blue dashed border and image icon
  - Images dropped at cursor position (centered under cursor)
  - Multiple files support: offset each subsequent image by 20px
  - Filter for valid image types: .png, .jpg, .gif, .webp (MIME type check)
  - Large images scaled down to max 800px while maintaining aspect ratio
- Files changed:
  - src/components/layout/Canvas.tsx (added drag-and-drop handlers, isDragOver state)
  - src/components/layout/Canvas.css (added .drop-indicator and .drop-indicator-content styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use e.dataTransfer.types.includes('Files') to check if drag contains files
  - Set e.dataTransfer.dropEffect = 'copy' to show copy cursor
  - Use pointer-events: none on drop indicator overlay so it doesn't block events
  - Check e.currentTarget === e.target for drag leave to avoid false triggers
  - Process multiple files with forEach and offset each image position
  - Reuse same image loading pattern from file picker (FileReader + Image)
---

## Iteration 31 - US-031: Implement video import and playback
- What was implemented:
  - File picker now accepts .mp4 and .webm video files in addition to images
  - Drag-and-drop supports video files (same formats)
  - Video thumbnail generation using HTMLVideoElement + canvas snapshot
  - Video thumbnail cache (videoThumbnailCache) for performance
  - Video element cache (videoElementCache) for reference
  - Video rendering on canvas: shows thumbnail with semi-transparent overlay and play button
  - Click on video object toggles playback state
  - Video plays inline using HTML5 video element overlaid on canvas
  - Video player has native controls (play/pause, scrub, volume, fullscreen)
  - Video stops when it ends (onEnded handler)
- Files changed:
  - src/types/canvas.ts (VideoObject already existed, no changes needed)
  - src/components/layout/Toolbar.tsx (added video file support to file picker, VideoObject import)
  - src/components/layout/Canvas.tsx (added video caches, video thumbnail rendering, playback state, video player overlay)
  - src/components/layout/Canvas.css (added .video-player styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use document.createElement('video') to create video element for thumbnail generation
  - Set video.muted = true and video.preload = 'metadata' for quick thumbnail generation
  - Listen to onloadeddata then seek to currentTime = 0, then onseeked to draw thumbnail
  - Canvas thumbnail: create canvas same size as video, drawImage(video) to capture frame
  - Video player uses style position to overlay on canvas at correct position
  - Remember to add playingVideoId to handleMouseDown dependency array
  - HTMLVideoElement.videoWidth and videoHeight give video dimensions
---

## Iteration 32 - US-032: Set up Yjs document and WebSocket provider
- What was implemented:
  - Installed yjs and y-websocket npm packages
  - Created collaborationStore.ts with Zustand store for collaboration state
  - Yjs document (Y.Doc) created for canvas state with getMap/getArray helpers
  - WebsocketProvider connects to y-websocket demo server (configurable)
  - Connection status tracked: 'disconnected', 'connecting', 'connected'
  - Graceful connection loss handling with reconnection attempts (up to 5)
  - Auto-connect on app mount using URL hash for room ID
  - TopBar updated to show real connection status from store
  - Connection status colors: green (connected), yellow pulsing (connecting), red (disconnected)
- Files changed:
  - package.json, package-lock.json (added yjs, y-websocket dependencies)
  - src/stores/collaborationStore.ts (created - Yjs document, WebSocket provider, connection state)
  - src/components/layout/TopBar.tsx (added collaboration store integration)
  - src/components/layout/TopBar.css (added connecting state styles with pulse animation)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use Y.Doc.getMap('name') and Y.Doc.getArray('name') to create shared data types
  - WebsocketProvider events: 'status', 'sync', 'connection-close', 'connection-error'
  - Use useEffect with empty deps to connect on mount
  - Export ydoc from collaborationStore for use in other stores (canvasStore sync)
  - Room ID prefix 'karta-' avoids conflicts with other Yjs apps on demo server
  - Next task (US-033) will sync canvasStore objects with Yjs document
---

## Iteration 33 - US-033: Sync canvas objects via Yjs
- What was implemented:
  - Bidirectional sync between canvasStore and Yjs document
  - Y.Map for each object with all properties synced
  - Object creation triggers yObjects.set() with new Y.Map
  - Object updates trigger yMap.set() for changed properties
  - Object deletion triggers yObjects.delete()
  - Yjs observe() and observeDeep() handlers for remote changes
  - isApplyingRemoteChanges flag to prevent sync loops
  - initializeYjsSync() action to set up observers and load initial state
  - App.tsx connects to room and initializes sync on connection
  - Removed test objects - canvas now starts empty or loads from Yjs
- Files changed:
  - src/stores/canvasStore.ts (added Yjs sync, initializeYjsSync action, isInitialized state)
  - src/stores/collaborationStore.ts (fixed Event type for connection-error handler)
  - src/App.tsx (removed test objects, added sync initialization)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use Y.Map for nested object properties (each canvas object is a Y.Map)
  - Check event.transaction.local to skip changes we originated
  - Use isApplyingRemoteChanges flag to prevent sync loops during remote updates
  - observeDeep() catches property changes within nested Y.Maps
  - Convert CanvasObject to plain object before storing in Y.Map
  - Type assertion: `obj as unknown as CanvasObject` for Record<string, unknown>
  - Initialize sync only after WebSocket connection is established
---

## Iteration 34 - US-034: Implement cursor presence
- What was implemented:
  - Yjs awareness API for broadcasting cursor positions
  - CursorPresence component that displays other users' cursors
  - Cursor updates throttled to ~30fps (33ms interval)
  - Cursors fade out after 5 seconds of inactivity
  - Random user name and color generation for each session
  - Remote cursors displayed with colored pointer SVG and name label
- Files changed:
  - src/stores/collaborationStore.ts (added UserPresence type, awareness setup, setLocalCursor, clearLocalCursor actions)
  - src/components/layout/CursorPresence.tsx (created - cursor presence rendering)
  - src/components/layout/CursorPresence.css (created - cursor styles)
  - src/components/layout/Canvas.tsx (added CursorPresence component)
  - src/components/layout/index.ts (exported CursorPresence)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use provider.awareness.setLocalStateField() to broadcast cursor position
  - Use provider.awareness.on('change') to listen for remote cursor updates
  - Store timestamps outside React state in module-scope Map to avoid ESLint purity errors
  - Use useMemo with currentTime state for fade calculations (avoid Date.now() during render)
  - ESLint rules prohibit: calling impure functions during render, setState in effects, ref access during render
  - Use functional state updates with setCurrentTime for periodic updates
  - Cursor presence layer needs pointer-events: none to not block canvas interactions
---

## Iteration 35 - US-035: Implement user avatar and presence list
- What was implemented:
  - User avatars displayed in top bar showing connected users
  - Local user avatar shown first, then remote users from remoteUsers Map
  - Avatars are colored circles with user's assigned color (from awareness)
  - Initials extracted from user name (e.g., "Happy Fox" -> "HF")
  - Tooltip shows username on hover, with "(you)" suffix for local user
  - "+N" indicator when more than 4 users connected (overflow-indicator)
  - Avatars overlap slightly with negative margin for compact display
  - Hover effect lifts avatar with z-index for visibility
- Files changed:
  - src/components/layout/TopBar.tsx (added localUser/remoteUsers state, allUsers memo, avatar rendering)
  - src/components/layout/TopBar.css (added user-avatars container, avatar styles, overflow indicator)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use useMemo to combine local + remote users into single array for rendering
  - Import UserPresence type from collaborationStore for type safety
  - getInitials helper: split by whitespace, take first char of first two words
  - Negative margin creates overlapping avatar stack effect
  - Local user gets special border color to distinguish from remote users
---

## Iteration 36 - US-036: Implement export selection as PNG
- What was implemented:
  - ExportSection component with transparent background checkbox and export button
  - Export logic that calculates bounding box with padding for selected/all objects
  - Handles rotated objects by using diagonal as bounding radius
  - drawObjectForExport function that renders objects without viewport transform
  - Image and video thumbnail loading with caching for export
  - PNG download via canvas.toDataURL() and link.click()
  - Button label changes: "EXPORT SELECTION" when objects selected, "EXPORT CANVAS" otherwise
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added export section, image/video loading, draw functions)
  - src/components/layout/PropertiesPanel.css (added export section styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - For rotated objects, use diagonal (sqrt(w*w + h*h)) to calculate bounding box
  - Canvas export: create offscreen canvas, draw objects, use toDataURL('image/png')
  - Trigger download: create <a> element, set download and href, call click()
  - Wrap case blocks with lexical declarations (const) in braces for ESLint
  - Export section is non-collapsible (just header + content)
  - Use async/await for image/video loading in sequential draw loop
---

## Iteration 37 - US-037: Implement undo/redo
- What was implemented:
  - History state in canvasStore: history array, historyIndex, isUndoRedoing flag
  - HistorySnapshot interface stores serializable canvas state (objects as array of [id, obj] tuples)
  - pushHistory() action creates snapshot before modifications
  - undo() action restores previous state and syncs to Yjs
  - redo() action restores forward state and syncs to Yjs
  - canUndo() and canRedo() boolean helpers for UI
  - MAX_HISTORY_SIZE constant limits history to 50 states
  - Keyboard shortcuts: Ctrl+Z (undo), Ctrl+Shift+Z (redo), Ctrl+Y (redo)
  - pushHistory called automatically in addObject, deleteObject, reorderObject
  - pushHistory called manually in Canvas.tsx before drag, resize, rotation operations
- Files changed:
  - src/stores/canvasStore.ts (added history state, pushHistory/undo/redo actions)
  - src/hooks/useKeyboardShortcuts.ts (added Ctrl+Z, Ctrl+Shift+Z, Ctrl+Y shortcuts)
  - src/components/layout/Canvas.tsx (added pushHistory calls before drag/resize/rotate)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Store history as array of snapshots; use historyIndex to track current position
  - When undoing from latest state, save current state first so redo can restore it
  - Redo index is historyIndex + 2 because we save current state before undo
  - For updateObject/updateObjects (called frequently during drag), call pushHistory before operation starts (in mouse down handler), not on every update
  - isUndoRedoing flag prevents pushHistory during undo/redo operations
  - Map can be constructed from array of [key, value] tuples: new Map(snapshot.objects)
  - Yjs sync during undo/redo: delete missing objects, update/add existing ones in transaction
---

## Iteration 38 - US-038: Implement delete selected objects
- What was implemented:
  - Delete and Backspace keyboard shortcuts to delete selected objects
  - deleteSelectedObjects action in canvasStore that deletes all selected objects
  - History is pushed once before batch delete (undoable)
  - Multiple selected objects deleted together in a single operation
  - Selection cleared after deletion
  - Yjs sync for collaborative deletion
- Files changed:
  - src/stores/canvasStore.ts (added deleteSelectedObjects action)
  - src/hooks/useKeyboardShortcuts.ts (added Delete/Backspace shortcut handling)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - For batch operations that need undo, push history once before the operation (not per item)
  - Use Array.from(state.selectedIds) to convert Set to array for iteration
  - Both Delete and Backspace keys should be handled (event.key === 'Delete' || event.key === 'Backspace')
  - Remember to add new store actions to the useEffect dependencies array
---

## Iteration 39 - US-039: Implement copy/paste
- What was implemented:
  - Clipboard state in canvasStore (CanvasObject[] array)
  - copySelection action: deep clones selected objects to clipboard
  - paste action: creates new objects from clipboard with 10px,10px offset
  - duplicate action: creates new copies in place (no offset) via Ctrl+D
  - Keyboard shortcuts: Ctrl+C (copy), Ctrl+V (paste), Ctrl+D (duplicate)
  - Pasted/duplicated objects automatically become the new selection
  - History pushed before paste/duplicate for undo support
  - Successive pastes continue to offset (clipboard positions updated)
  - Yjs sync for collaborative paste/duplicate
- Files changed:
  - src/stores/canvasStore.ts (added clipboard state, copySelection/paste/duplicate actions)
  - src/hooks/useKeyboardShortcuts.ts (added Ctrl+C/V/D shortcut handling)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use JSON.parse(JSON.stringify(obj)) for deep cloning objects with nested properties
  - Update clipboard positions after paste for successive paste with cascading offset
  - Duplicate is similar to copy+paste but uses original positions and single step
  - crypto.randomUUID() generates unique IDs for pasted objects
---

## PRD-04: Error Handling and User Feedback
- What was implemented:
  - React Error Boundary component (ErrorBoundary.tsx) with fallback UI and retry button
  - Toast notification system with Zustand store (toastStore.ts)
  - ToastContainer component displaying stacked notifications in bottom-right
  - Four toast types: success (green), error (red), warning (yellow), info (blue)
  - Auto-dismiss after 3 seconds by default, configurable duration
  - Toast feedback for copy/paste/delete/duplicate operations
  - Error handling for file operations (FileReader, Image, Video load errors)
  - Export feedback (success/error toasts) in PropertiesPanel
  - Connection status feedback (connected/disconnected/reconnecting toasts)
  - Undo/redo feedback toasts
- Files created:
  - src/stores/toastStore.ts (Toast interface, useToastStore with addToast/removeToast)
  - src/components/ErrorBoundary.tsx (React class component for error boundary)
  - src/components/ErrorBoundary.css (error boundary styling)
  - src/components/Toast.tsx (ToastContainer component)
  - src/components/Toast.css (toast notification styles with animations)
- Files changed:
  - src/App.tsx (added ErrorBoundary wrapping Canvas/PropertiesPanel, added ToastContainer)
  - src/stores/canvasStore.ts (added toasts for delete, copy, paste, duplicate, undo, redo)
  - src/stores/collaborationStore.ts (added toasts for connection status changes)
  - src/components/layout/Toolbar.tsx (added error handling for file reader, image, video loads)
  - src/components/layout/Canvas.tsx (added error handling for drag-drop file operations)
  - src/components/layout/PropertiesPanel.tsx (added export success/error toasts)
- Learnings for future iterations:
  - Use useToastStore.getState().addToast() to add toasts from outside React components (stores)
  - Toast auto-dismiss uses setTimeout in the store, cleanup on removeToast
  - ErrorBoundary must be class component to use componentDidCatch and getDerivedStateFromError
  - Position toasts above status bar (bottom: 60px) to not overlap
  - slideIn animation creates smooth entrance effect
---

## PRD-Polish Iteration 1 - Performance Review (reviewer)
- What was reviewed:
  - Canvas render loop profiling
  - Mouse event handler analysis
  - Event listener cleanup audit
  - QuadTree spatial index usage
  - Large object count performance

### Canvas Render Loop Findings:
- The draw() function is called via useEffect whenever state changes (objects, selectedIds, viewport, etc.)
- Array.from(objects.values()).filter().sort() runs on every draw call (Canvas.tsx:567-569) - should be memoized
- Radial gradient for background is recreated on every draw (minor)
- Grid drawing creates separate path operations for each line (could batch)

### Mouse Event Handler Findings:
- handleMouseMove updates cursor position on every move via store (setCursorPosition) - triggers re-renders
- No throttling on position updates during drag operations
- Tool event processing could benefit from throttling during intensive operations

### Event Listener Cleanup - All Good:
- Window resize listener: properly cleaned up ✓
- Space key listeners (keydown/keyup): properly cleaned up ✓
- Panning window listeners: properly cleaned up ✓
- No memory leaks detected in event listener patterns

### QuadTree Usage - CRITICAL ISSUES:
- QuadTree exists and is properly implemented in src/utils/quadtree.ts
- Spatial index is rebuilt on add/delete operations (canvasStore.ts)
- **CRITICAL**: hitTest() in Canvas.tsx (line 719-772) does NOT use the spatial index - iterates through all objects O(n)
- **CRITICAL**: getObjectsInRect() (line 907-914) in tool context doesn't use spatial index either
- querySpatialIndex() exists in canvasStore but is not being used by Canvas component

### Large Object Count Performance Issues:
1. hitTest() performs O(n) iteration through all objects instead of O(log n) quadtree lookup
2. Object sorting (by zIndex) happens on every draw frame instead of being cached
3. Selection rendering iterates through all selectedIds on each draw

### Recommendations (for impl agents to pick up):
1. Use querySpatialIndex() for hit testing instead of iterating all objects
2. Memoize sorted objects array using useMemo with objects dependency
3. Consider throttling cursor position updates (e.g., 60fps max)
4. Batch grid line drawing into fewer path operations
5. Cache the viewport-visible objects using quadtree query for culling

- Tasks marked complete in PRD.md: None (review only, findings documented)
- Learnings for future iterations:
  - QuadTree is implemented but underutilized - integration opportunities exist
  - React useEffect dependency arrays trigger redraws - be careful what state is included
  - Event listener patterns in the codebase follow proper cleanup conventions
  - Performance bottlenecks are primarily in rendering/hit testing, not memory leaks
---

---

## Iteration (Polish) - impl-2: Clipboard edge case handling
- What was implemented:
  - Added validation for clipboard operations (copy, paste, duplicate)
  - Added isValidCanvasObject() function to validate required BaseObject properties
  - Added sanitizeNumber() function to handle NaN/Infinity values
  - Added sanitizeObjectNumbers() to clamp values (opacity 0-1) and replace invalid numbers
  - Added safeDeepClone() with try-catch for JSON.parse failures
  - Copy now validates and sanitizes objects before storing
  - Paste validates clipboard items before creating new objects, skips invalid ones
  - Duplicate validates source objects before creating copies
  - Early return with console warning when no valid objects to paste/duplicate
- Files changed:
  - src/stores/clipboardStore.ts (added validation functions, updated copy/paste/duplicate)
  - PRD.md (marked task complete)
- Learnings:
  - Validate objects at clipboard boundaries to prevent corrupted data propagation
  - Use type guards (isValidCanvasObject) for runtime validation of object structure
  - Sanitize numeric values with finite checks - NaN/Infinity can break canvas rendering
  - safeDeepClone wraps JSON.parse in try-catch for graceful handling of circular refs


---

## Iteration (Polish) - impl-2: Extreme position coordinate handling
- What was implemented:
  - Added coordinate validation/sanitization utilities to geometryUtils.ts:
    - MAX_COORDINATE = 1,000,000 and MIN_COORDINATE = -1,000,000 constants
    - MIN_DIMENSION = 0.01 and MAX_DIMENSION = 100,000 constants
    - isFiniteNumber() - checks for valid finite numbers
    - clampCoordinate() - clamps x/y values to safe bounds
    - clampDimension() - clamps width/height to safe bounds
    - hasValidCoordinates() - validates all geometric properties
    - sanitizeCoordinates() - sanitizes x, y, width, height on an object
  - Integrated sanitization in canvasStore.addObject()
  - Integrated sanitization in yjsUtils.yjsToObject() for Yjs sync
  - Fixed ESLint errors: removed unused import, changed let to const
- Files changed:
  - src/utils/geometryUtils.ts (added coordinate validation functions)
  - src/utils/yjsUtils.ts (added coordinate sanitization to yjsToObject)
  - src/stores/canvasStore.ts (added sanitization to addObject)
  - PRD.md (marked task complete)
- Learnings:
  - Canvas 2D works best with coordinates < 1 million pixels
  - Sanitize at boundaries: object creation and Yjs sync
  - Use Number.isFinite() to check for NaN/Infinity
  - Clamping is safer than rejecting - prevents data loss


---

## PRD-Polish Iteration 1 - impl-1: Code Quality Improvements
- What was implemented:
  - Extracted Yjs serialization utilities into src/utils/yjsUtils.ts
    - objectToYjs(), yjsToObject(), isValidBaseObject(), isValidTypeSpecificProps()
    - createYjsUpdateQueue() for debounced Yjs sync
  - Created src/utils/geometryUtils.ts with:
    - BoundingBox interface
    - calculateBoundingBox() moved from canvasStore.ts
    - getBoundingBoxCenter(), boundingBoxesIntersect(), isPointInBounds()
    - expandBounds(), normalizeRect() utility functions
  - Added JSDoc comments to exported interfaces and stores:
    - canvasStore.ts: GridSettings, SnapGuide, useCanvasStore
    - historyStore.ts: HistorySnapshot, HistoryState, useHistoryStore
    - clipboardStore.ts: ClipboardState, PASTE_OFFSET
    - toastStore.ts: Toast, DEFAULT_TOAST_DURATION, useToastStore
  - Eliminated `as any` casts:
    - Fixed canvasStore.ts selectAll() to properly type narrow GroupObject
    - Fixed templateStore.ts TemplateObject.type to use ObjectType instead of string
    - Removed eslint-disable comment in TemplatePanel.tsx
  - Extracted magic numbers into named constants in Canvas.tsx:
    - CTRL_ZOOM_SENSITIVITY, DEFAULT_FONT_WEIGHT, DEFAULT_LINE_HEIGHT
    - DOUBLE_CLICK_THRESHOLD_MS, EDITING_START_DELAY_MS
    - MAX_IMPORTED_IMAGE_SIZE, ERROR_TOAST_DURATION_MS
- Files created:
  - src/utils/yjsUtils.ts
  - src/utils/geometryUtils.ts
- Files changed:
  - src/stores/canvasStore.ts (utility extraction, JSDoc, GroupObject import)
  - src/stores/historyStore.ts (JSDoc comments)
  - src/stores/clipboardStore.ts (JSDoc comments)
  - src/stores/toastStore.ts (JSDoc, DEFAULT_TOAST_DURATION constant)
  - src/stores/templateStore.ts (ObjectType import for type safety)
  - src/components/TemplatePanel.tsx (removed as any cast)
  - src/components/layout/Canvas.tsx (magic number constants)
- Learnings for future iterations:
  - Yjs utilities are reusable and could be shared across collaboration features
  - Type narrowing with TypeScript works well when checking obj.type === 'group'
  - Magic numbers in rendering code should be extracted early to improve readability
  - JSDoc comments on interfaces help developers understand expected values
---

- Reviewed error handling patterns in src/tools/:
  - All tools extend BaseTool and follow consistent patterns
  - Guard clauses at method start for early returns
  - { handled: false } returned when not applicable
  - Escape key cancels operations consistently
  - MIN_OBJECT_SIZE constant used consistently (10px)
  - State properly reset after operation completion/cancellation
  - Pattern already consistent - no changes needed

---

## PRD-Polish Iteration 1 - reviewer: Keyboard Shortcuts Audit
- What was reviewed:
  - Complete audit of useKeyboardShortcuts.ts against ShortcutsModal.tsx
  - Checked for conflicts between shortcuts
  - Verified all documented shortcuts are implemented

### Findings:

#### CRITICAL BUG: Missing Keyboard Shortcuts
The ShortcutsModal.tsx advertises these shortcuts that are NOT implemented in useKeyboardShortcuts.ts:
- `]` → Bring forward (NOT IMPLEMENTED)
- `[` → Send backward (NOT IMPLEMENTED)
- `Ctrl+]` → Bring to front (NOT IMPLEMENTED)
- `Ctrl+[` → Send to back (NOT IMPLEMENTED)

The store actions (bringToFront, bringForward, sendBackward, sendToBack) exist in canvasStore.ts but are not wired to keyboard shortcuts.

#### ESLint Errors Found (for impl agents to fix):
1. **ContextMenu.tsx:32** - `_targetObjectId` is defined but never used
2. **ContextMenu.tsx:109** - setState in useEffect (anti-pattern)
3. **NumberInput.tsx:35** - setState in useEffect (anti-pattern)
4. **ColorInput.tsx:122** - `updateColorFromHsv` is assigned but never used
5. **ArrowTool.ts:127** - `_e` is defined but never used
6. **Canvas.tsx:646** - unnecessary dependency 'imageLoadTrigger'

#### No Conflicts Found:
- All tool shortcuts (V, H, R, O, L, T, F, P) are unique
- Ctrl+B (Bold) vs Ctrl+Shift+B (Align Bottom) don't conflict
- Alignment and distribution shortcuts are properly namespaced

### Recommended Fix for Missing Shortcuts:
Add to useKeyboardShortcuts.ts:
```typescript
// ] key (bring forward)
if (event.key === ']') {
  if (event.ctrlKey) {
    bringToFront();
  } else {
    bringForward();
  }
  return;
}

// [ key (send backward)
if (event.key === '[') {
  if (event.ctrlKey) {
    sendToBack();
  } else {
    sendBackward();
  }
  return;
}
```

- Tasks marked complete in PRD.md: None (audit only)
- Learnings:
  - Always verify documented shortcuts match implementation
  - ShortcutsModal should be generated from actual shortcut config, not hardcoded


---

## PRD-Polish Iteration 2 - impl-1: Performance Optimization (from reviewer findings)
- What was implemented:
  - Optimized hitTest() in Canvas.tsx to use QuadTree spatial index
    - Changed from O(n) iteration through all objects to O(log n) spatial query
    - Uses querySpatialIndex() with a 200px query radius around click point
    - Maintains rotation-aware precise hit testing on candidate objects only
  - Memoized sorted objects array for rendering in Canvas.tsx
    - Created sortedTopLevelObjects using useMemo with objects dependency
    - Removed inline Array.from().filter().sort() from draw() function
    - Prevents re-sorting on every draw frame
- Files changed:
  - src/components/layout/Canvas.tsx (added useMemo import, querySpatialIndex subscription, memoized sortedTopLevelObjects, optimized hitTest)
- Learnings for future iterations:
  - Use spatial index for coarse candidate selection, then precise testing on candidates
  - Query radius of 100px accounts for rotated objects whose AABB may be offset
  - useMemo should be used for expensive computed values that depend on store state
  - Dependency arrays must include memoized values when used in useCallback
---

## PRD-Polish Iteration 2 - impl-2: SelectTool edge case handling
- What was implemented:
  - Added DRAG_THRESHOLD constant (3px) - prevents micro-drags during click attempts
  - Added MIN_MARQUEE_SIZE constant (2px) - prevents zero-size marquee selections
  - Added 'pending_drag' mode to SelectionMode type for drag threshold handling
  - Updated startDragging() to start in 'pending_drag' mode instead of immediate 'dragging'
  - Added handlePendingDragMove() method that checks if movement exceeds threshold
  - Updated finalizeMarquee() to check marquee size before selecting
  - Fixed division by zero in aspect ratio calculation (startState.height > 0 guard)
  - onMouseUp handles pending_drag mode gracefully (just a click if threshold not exceeded)
- Files changed:
  - src/tools/types.ts (added 'pending_drag' to SelectionMode)
  - src/tools/SelectTool.ts (added constants, pending drag handling, marquee size check)
  - PRD.md (marked task complete)
- Edge cases addressed:
  - Zero-size marquee: Now requires MIN_MARQUEE_SIZE (2px) minimum before selecting
  - Rapid clicks: Double-click detection already has threshold; click vs drag now differentiated
  - Drag threshold: DRAG_THRESHOLD (3px) must be exceeded before objects actually move
  - Division by zero: Aspect ratio calc now guards against zero height
- Learnings:
  - Use state machine with intermediate states (pending_drag) for threshold-based behaviors
  - Small pixel thresholds (3px) prevent accidental micro-movements without feeling laggy
  - Guard against edge case math (division by zero) at calculation sites
  - Marquee selection should have minimum size to avoid accidental empty-space clicks

---

## PRD-Polish Iteration 1 - reviewer: Fix Missing Keyboard Shortcuts
- What was implemented:
  - Added missing z-ordering keyboard shortcuts to useKeyboardShortcuts.ts:
    - `]` → Bring forward (one level up)
    - `[` → Send backward (one level down)
    - `Ctrl+]` → Bring to front (top of stack)
    - `Ctrl+[` → Send to back (bottom of stack)
  - Added bringToFront, bringForward, sendBackward, sendToBack store selectors
  - Added these functions to useEffect dependency array
- Files changed:
  - src/hooks/useKeyboardShortcuts.ts
- Verification:
  - npm run typecheck: PASS
  - npm run test: 390 passed, 2 failed (pre-existing failures in SelectTool.test.ts)
- Tasks marked complete in PRD.md:
  - [x] Verify keyboard shortcuts work consistently and don't conflict
- Learnings:
  - ShortcutsModal.tsx was advertising shortcuts that weren't implemented
  - Consider generating ShortcutsModal from actual shortcut config to keep in sync
  - Test failures in SelectTool.test.ts are pre-existing and unrelated to this change


---

## PRD-Polish Iteration 2 - impl-1: Error Boundary Coverage
- What was implemented:
  - Added ErrorBoundary wrapping to TopBar, Toolbar, and StatusBar components in App.tsx
  - Now all major UI sections are wrapped with error boundaries
- Files changed:
  - src/App.tsx (added ErrorBoundary wrapping to TopBar, Toolbar, StatusBar)
- Previous coverage:
  - Canvas ✓
  - TemplatePanel ✓
  - PropertiesPanel ✓
- Added coverage:
  - TopBar ✓
  - Toolbar ✓
  - StatusBar ✓
- Learnings:
  - Error boundaries should wrap all major UI sections to prevent cascading failures
  - ToastContainer and ShortcutsModal are intentionally not wrapped as they are lightweight
---

## PRD-Polish Iteration 2 - impl-2: Rotation handling in canvas operations
- What was implemented:
  - Added getRotatedBoundingBox() utility function to geometryUtils.ts
    - Calculates axis-aligned bounding box for rotated rectangles
    - Used for spatial indexing and bounding box calculations
  - Updated calculateBoundingBox() to use rotation-aware bounds
    - Now properly accounts for rotation when calculating combined bounds
  - Fixed objectIntersectsRect() in Canvas.tsx for marquee selection
    - Now calculates rotated corners and checks intersection properly
    - Checks both rotated object corners inside marquee AND marquee corners inside rotated object
    - Falls back to AABB comparison of rotated bounds for edge cases
  - Updated rebuildSpatialIndex() in canvasStore.ts
    - Objects now inserted with rotation-aware bounding boxes
    - Ensures spatial queries return correct candidates for rotated objects
  - Updated querySpatialIndex() fallback path to use rotation-aware bounds
- Files changed:
  - src/utils/geometryUtils.ts (added getRotatedBoundingBox function)
  - src/components/layout/Canvas.tsx (fixed objectIntersectsRect for rotation)
  - src/stores/canvasStore.ts (rotation-aware spatial indexing)
  - PRD.md (marked task complete)
- Operations now rotation-aware:
  - Marquee selection correctly selects rotated objects
  - Spatial index queries account for rotation
  - Bounding box calculations include rotation
  - hitTest was already rotation-aware (no changes needed)
- Learnings:
  - Rotated rectangle AABB = transform all 4 corners, find min/max
  - For intersection tests, check corners in both directions (A corners in B, B corners in A)
  - Spatial indexing with AABB is still efficient if using rotated AABB
  - Multiple intersection checks needed: corners inside other shape AND AABB overlap


---

## PRD-Polish Iteration 2 - impl-1: Cursor Changes Review
- What was reviewed:
  - Verified cursor handling across all tools via tool system
  - BaseTool.setCursor() properly propagates to ToolContext.setCursor()
  - Canvas getCursorStyle() handles special cases (panning, space pressed)
- Findings (all correct):
  - HandTool: grab/grabbing ✓
  - SelectTool: default, move, grab (rotation), directional resize cursors ✓
  - TextTool: text (I-beam) ✓
  - Drawing tools (Rectangle, Ellipse, Frame, Line, Arrow, Pen): crosshair ✓
  - HANDLE_CURSORS mapping correctly maps all 8 handles to directional cursors
- Status: No changes needed - cursor system is well-implemented
---

## PRD-Polish Iteration 2 - impl-2: Export rotation/groups handling
- What was implemented:
  - Removed duplicate calculateBoundingBox from exportUtils.ts
    - Now imports from geometryUtils.ts (which handles rotation)
    - Re-exports for backwards compatibility with existing imports
  - Updated SVG export for groups:
    - Groups now render as SVG <g> elements with proper transform
    - Added renderObjectToSVG() recursive function for nested group support
    - Children are rendered inside their parent group's <g> element
    - Top-level objects filtered (skip children that are part of groups)
  - SVG export already handled rotation via transform attribute (verified working)
  - PNG export already handled rotation via Canvas2D transform (verified working)
- Files changed:
  - src/utils/exportUtils.ts (removed duplicate, added group support)
  - PRD.md (marked task complete)
- Rotation handling now consistent:
  - Bounding box calculation uses rotation-aware AABB from geometryUtils
  - SVG export uses transform="rotate()" for proper rotation
  - PNG export uses ctx.rotate() for proper rotation
  - Groups export with their children properly nested
- Learnings:
  - Don't duplicate utility functions - import from single source of truth
  - SVG groups (<g>) are useful for grouping transforms and opacity
  - Recursive rendering needed for nested groups in export
  - Filter parentId to avoid rendering children outside their groups
