# Progress Log

## Learnings
(Patterns discovered during implementation)
- Use `npm create vite@latest temp-folder -- --template react-ts` to avoid non-empty directory issues, then copy files
- Vite template comes with ESLint pre-configured, just need to add eslint-config-prettier
- Add safe.directory to git config on Windows for network drives: `git config --global --add safe.directory <path>`

---

## Iteration 1 - US-001: Initialize project with Vite + React + TypeScript
- What was implemented:
  - Vite project with React 19 + TypeScript template
  - ESLint configuration with TypeScript, React hooks, React refresh plugins
  - Prettier configuration (.prettierrc)
  - Folder structure: src/components, src/hooks, src/stores, src/utils, src/types
  - Added typecheck and format npm scripts
- Files changed:
  - package.json (created, modified name/version/scripts)
  - eslint.config.js (created, modified to add prettier)
  - .prettierrc (created)
  - .gitignore (created)
  - All Vite template files
  - src/ folder structure with .gitkeep files
- Learnings for future iterations:
  - Typecheck command: `npm run typecheck`
  - Lint command: `npm run lint`
  - Dev server: `npm run dev` (runs on localhost:5173)
---

## Iteration 2 - US-002: Create app shell with layout structure
- What was implemented:
  - Flexbox-based layout with TopBar, Toolbar, Canvas, PropertiesPanel, StatusBar
  - Dark theme with CSS variables (--color-bg-primary: #1a1a1a, --color-bg-secondary: #2a2a2a)
  - Layout components in src/components/layout/
  - Collapsible properties panel with toggle button
  - Status bar with placeholder position and selection display
- Files changed:
  - src/index.css (global styles + CSS variables)
  - src/App.css (main layout)
  - src/App.tsx (component composition)
  - src/components/layout/Toolbar.tsx + .css
  - src/components/layout/TopBar.tsx + .css
  - src/components/layout/PropertiesPanel.tsx + .css
  - src/components/layout/Canvas.tsx + .css
  - src/components/layout/StatusBar.tsx + .css
  - src/components/layout/index.ts (barrel export)
- Learnings for future iterations:
  - Layout uses CSS variables for dimensions: --toolbar-width, --topbar-height, etc.
  - Components are organized in src/components/layout/
  - Use barrel exports (index.ts) for cleaner imports
---

## Iteration 3 - US-003: Implement canvas with pan and zoom
- What was implemented:
  - HTML Canvas element with 2D context, fills container and handles window resize
  - Device pixel ratio (DPR) scaling for crisp rendering on high-DPI displays
  - Mouse wheel zoom centered on cursor position (10% to 500% range)
  - Middle-mouse button drag for panning
  - Space+left-click drag for panning (alternative method)
  - Dot grid pattern that scales with zoom and moves with pan
  - Cursor changes to grab/grabbing during pan operations
- Files changed:
  - src/components/layout/Canvas.tsx (complete rewrite with pan/zoom logic)
  - src/components/layout/Canvas.css (added .canvas class styles)
- Learnings for future iterations:
  - Viewport state: { x, y, zoom } where x/y are pan offsets in canvas coords
  - Canvas uses requestAnimationFrame-compatible draw() callback
  - Use useCallback for handlers to prevent unnecessary re-renders
  - Window keydown/keyup listeners for Space key pan mode
  - Grid offset calculation: (panOffset * zoom) % gridSpacing for seamless tiling
---

## Iteration 4 - US-004: Create Zustand store for canvas state
- What was implemented:
  - Installed Zustand package for state management
  - Created TypeScript interfaces in src/types/canvas.ts for all canvas object types
  - Created Zustand store in src/stores/canvasStore.ts with:
    - State: objects (Map), selectedIds (Set), viewport
    - Actions: addObject, updateObject, deleteObject, setSelection, setViewport
  - All object types extend BaseObject with id, type, x, y, width, height, rotation, opacity
- Files changed:
  - package.json (added zustand dependency)
  - src/types/canvas.ts (created - object type definitions)
  - src/stores/canvasStore.ts (created - Zustand store)
- Learnings for future iterations:
  - Store import: `import { useCanvasStore } from '../stores/canvasStore'`
  - Types import: `import type { CanvasObject, Viewport } from '../types/canvas'`
  - Using Map and Set for objects/selectedIds for O(1) lookups
  - Object types: rectangle, ellipse, text, frame, path, image, video
  - Tool types: select, hand, rectangle, text, frame, pen
---

## Iteration 5 - US-005: Build left toolbar with tool buttons
- What was implemented:
  - Added activeTool state and setActiveTool action to Zustand store
  - Vertical toolbar with 6 tool buttons: Select (V), Hand (H), Rectangle (R), Text (T), Frame (F), Pen (P)
  - Each button has a custom SVG icon
  - Active tool highlighted with accent color (--color-accent: #0066ff)
  - Tooltips on hover showing tool name + keyboard shortcut
  - Divider line after Text tool to separate tool groups
- Files changed:
  - src/stores/canvasStore.ts (added activeTool state and setActiveTool action)
  - src/components/layout/Toolbar.tsx (added tool buttons with icons)
  - src/components/layout/Toolbar.css (added styles for buttons, active state, tooltips, divider)
- Learnings for future iterations:
  - Tool buttons use position: relative with tooltip positioned absolutely to the right
  - Tooltip appears on hover with opacity transition
  - Store state selector: `useCanvasStore((state) => state.activeTool)`
  - setActiveTool can be called with ToolType to switch tools
---

## Iteration 6 - US-006: Implement tool state and keyboard shortcuts
- What was implemented:
  - Created useKeyboardShortcuts hook in src/hooks/useKeyboardShortcuts.ts
  - Global keyboard event listener for tool switching shortcuts
  - Shortcuts: V (select), H (hand), R (rectangle), T (text), F (frame), P (pen)
  - Shortcuts disabled when typing in input fields, textareas, or contenteditable elements
  - Shortcuts also disabled when modifier keys (Ctrl/Meta/Alt) are pressed
  - Wired up hook in App.tsx to enable shortcuts globally
- Files changed:
  - src/hooks/useKeyboardShortcuts.ts (created)
  - src/App.tsx (added hook import and call)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Check target.tagName for INPUT/TEXTAREA and target.isContentEditable to disable shortcuts
  - Use window.addEventListener for global keyboard shortcuts
  - Remember to clean up listeners in useEffect return
---

## Iteration 7 - US-007: Implement selection tool with click-to-select
- What was implemented:
  - Hit testing function to detect clicks on objects (with rotation support)
  - Click on object selects it (updates selectedIds in store)
  - Click on empty canvas deselects all
  - Selection box with 8 resize handles + rotation handle
  - Selection highlight color: blue (#0066ff)
  - Shift+click toggles selection (add/remove from selection)
  - Coordinate conversion helpers: canvasToScreen, screenToCanvas
  - Object rendering for all types: rectangle, ellipse, text, frame, path
- Files changed:
  - src/components/layout/Canvas.tsx (added hitTest, drawObject, drawSelectionBox, selection handling)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Hit testing with rotation: translate point relative to object center, apply inverse rotation, then check bounds
  - Draw selection boxes after objects so they appear on top
  - Handle positions array pattern: corners and edge midpoints for 8 handles
  - Rotation handle: positioned above top-center with connecting line
  - Store selectors: use separate selectors to avoid unnecessary re-renders
---

## Iteration 8 - US-008: Implement selection tool drag-to-move
- What was implemented:
  - Added updateObjects batch action to store for efficient multi-object updates
  - Drag state tracking (isDragging, hoveredObjectId) in Canvas component
  - Drag-to-move for selected objects with real-time position updates
  - Multiple selected objects move together using batch updates
  - Hover detection for move cursor on selected objects
  - Added test objects in App.tsx for development testing
  - Fixed JSX.Element type to use ReactNode in Toolbar
- Files changed:
  - src/stores/canvasStore.ts (added updateObjects batch action)
  - src/components/layout/Canvas.tsx (added drag handling and hover detection)
  - src/components/layout/Toolbar.tsx (fixed JSX.Element type)
  - src/App.tsx (added test objects for development)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use batch updates (updateObjects) for moving multiple objects to avoid re-render overhead
  - Track drag state with refs (lastMousePos, dragStartCanvasPos) to avoid state update lag
  - Movement delta = (screen delta) / zoom for correct canvas coordinate translation
  - Cursor style logic: check isDragging first, then hoveredObjectId for hover state
---

## Iteration 9 - US-009: Implement marquee selection
- What was implemented:
  - Marquee selection state tracking (isMarqueeSelecting, marqueeStart, marqueeEnd refs)
  - Drag on empty canvas draws selection rectangle with dashed blue border and semi-transparent blue fill
  - Objects intersecting marquee rectangle are selected on mouse up (AABB intersection check)
  - Shift+drag adds to existing selection (preserves current selection)
  - Fixed ESLint error: added braces around case 'text' block for lexical declaration
- Files changed:
  - src/components/layout/Canvas.tsx (added marquee selection logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use refs (marqueeStart, marqueeEnd, marqueeShiftKey) for tracking marquee state during drag
  - AABB intersection check: !(obj.x > maxX || objRight < minX || obj.y > maxY || objBottom < minY)
  - Force redraw during marquee drag by calling draw() directly to show marquee rectangle
  - ctx.setLineDash([4, 4]) creates dashed border effect
  - Remember to handle mouseLeave to cancel marquee selection if mouse leaves canvas
---

## Iteration 10 - US-010: Implement resize via selection handles
- What was implemented:
  - HandleType type definition for 8 handle types (nw, n, ne, e, se, s, sw, w)
  - HANDLE_POSITIONS array with position getters for each handle
  - HANDLE_CURSORS map for appropriate resize cursors
  - hitTestHandle function to detect clicks on resize handles with rotation support
  - Resize logic for all 8 handles with proportional/free resize support
  - Corner handles: proportional resize by default, Shift for free resize
  - Edge handles: single dimension resize only
  - Minimum size enforcement (10x10px MIN_OBJECT_SIZE constant)
  - Cursor changes to resize cursors on handle hover
  - State: isResizing, activeResizeHandle, hoveredHandle
  - Refs: resizeHandle, resizeStartObjState, resizeShiftKey
- Files changed:
  - src/components/layout/Canvas.tsx (added resize handle types, hit testing, resize logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use state (activeResizeHandle) instead of ref for cursor style to avoid ESLint ref-during-render errors
  - Handle hit testing: transform click point to object's local coordinate system using inverse rotation
  - Resize proportionally: use aspect ratio and decide which dimension to follow based on larger delta
  - For handles that affect position (nw, n, ne, w, sw), recalculate x/y based on new dimensions
  - Enforce minimum size by clamping dimensions and recalculating position for affected handles
---

## Iteration 11 - US-011: Implement rotation via handle
- What was implemented:
  - RotationHandle type definition ('rotation' | null)
  - hitTestRotationHandle function to detect clicks on rotation handle
  - Rotation state tracking: isRotating, hoveredRotationHandle, rotationStartAngle, rotationObjStartRotation
  - Drag rotation handle rotates object around its center
  - Shift+drag snaps rotation to 15° increments
  - Cursor changes to 'grab' when hovering rotation handle
  - Rotation is calculated using Math.atan2 to get angle from object center to mouse position
- Files changed:
  - src/components/layout/Canvas.tsx (added rotation handle types, hit testing, rotation logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use Math.atan2(dy, dx) to calculate angle from center to mouse position
  - Add +90 offset because rotation handle is at top (not right side like 0° in atan2)
  - Track rotation start angle and object's starting rotation to calculate delta
  - Normalize rotation to 0-360 range: ((rotation % 360) + 360) % 360
  - Snap to increments: Math.round(value / increment) * increment
  - Check rotation handle hit test BEFORE resize handles since rotation handle is above object
---

## Iteration 12 - US-012: Implement rectangle tool
- What was implemented:
  - Rectangle tool drawing functionality in Canvas.tsx
  - State: isDrawingRect to track when user is drawing
  - Refs: rectDrawStart, rectDrawEnd, rectDrawShiftKey for tracking draw state
  - drawRectPreview function to show rectangle preview while drawing
  - On mouse down with rectangle tool: start drawing at click position
  - On mouse move: update preview, Shift constrains to square
  - On mouse up: create rectangle object with default fill (#4a4a4a), add to store
  - Tool automatically switches to Select after drawing
  - Minimum size check (10x10px) before creating rectangle
  - Uses crypto.randomUUID() for generating unique object IDs
- Files changed:
  - src/components/layout/Canvas.tsx (added rectangle tool logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Import RectangleObject type from types/canvas for typed object creation
  - Use refs for tracking draw start/end to avoid state update lag during drag
  - crypto.randomUUID() is built into modern browsers, no need for nanoid
  - Square constraint: Math.max(abs(width), abs(height)) for both dimensions with sign preserved
  - Normalize negative dimensions: x = width >= 0 ? start.x : start.x + width
  - Remember to add isDrawingRect to all relevant dependency arrays
---

## Iteration 13 - US-013: Implement ellipse shape variant
- What was implemented:
  - Alt+Rectangle tool draws ellipse instead of rectangle
  - Ellipse preview shown while drawing when Alt is held
  - Shift constrains to circle (both for preview and final shape)
  - Alt key is tracked during mouse down, move, and up events
  - EllipseObject type imported and used for ellipse creation
- Files changed:
  - src/components/layout/Canvas.tsx (added Alt key tracking and ellipse drawing logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use rectDrawAltKey ref to track Alt key state during drawing operation
  - Ellipse rendering uses ctx.ellipse() with center position and radii
  - Alt key can be toggled during drawing to switch between rectangle and ellipse preview
  - EllipseObject type already existed in canvas.ts, rendering was also already implemented
---
