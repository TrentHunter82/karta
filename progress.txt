# Progress Log

## Learnings
(Patterns discovered during implementation)
- Use `npm create vite@latest temp-folder -- --template react-ts` to avoid non-empty directory issues, then copy files
- Vite template comes with ESLint pre-configured, just need to add eslint-config-prettier
- Add safe.directory to git config on Windows for network drives: `git config --global --add safe.directory <path>`
- Don't use useEffect to setState from props - display prop value directly when not editing
- Don't use refs during render (e.g. prevValueRef.current in conditionals) - ESLint strict mode disallows this

---

## Iteration 1 - US-001: Initialize project with Vite + React + TypeScript
- What was implemented:
  - Vite project with React 19 + TypeScript template
  - ESLint configuration with TypeScript, React hooks, React refresh plugins
  - Prettier configuration (.prettierrc)
  - Folder structure: src/components, src/hooks, src/stores, src/utils, src/types
  - Added typecheck and format npm scripts
- Files changed:
  - package.json (created, modified name/version/scripts)
  - eslint.config.js (created, modified to add prettier)
  - .prettierrc (created)
  - .gitignore (created)
  - All Vite template files
  - src/ folder structure with .gitkeep files
- Learnings for future iterations:
  - Typecheck command: `npm run typecheck`
  - Lint command: `npm run lint`
  - Dev server: `npm run dev` (runs on localhost:5173)
---

## Iteration 2 - US-002: Create app shell with layout structure
- What was implemented:
  - Flexbox-based layout with TopBar, Toolbar, Canvas, PropertiesPanel, StatusBar
  - Dark theme with CSS variables (--color-bg-primary: #1a1a1a, --color-bg-secondary: #2a2a2a)
  - Layout components in src/components/layout/
  - Collapsible properties panel with toggle button
  - Status bar with placeholder position and selection display
- Files changed:
  - src/index.css (global styles + CSS variables)
  - src/App.css (main layout)
  - src/App.tsx (component composition)
  - src/components/layout/Toolbar.tsx + .css
  - src/components/layout/TopBar.tsx + .css
  - src/components/layout/PropertiesPanel.tsx + .css
  - src/components/layout/Canvas.tsx + .css
  - src/components/layout/StatusBar.tsx + .css
  - src/components/layout/index.ts (barrel export)
- Learnings for future iterations:
  - Layout uses CSS variables for dimensions: --toolbar-width, --topbar-height, etc.
  - Components are organized in src/components/layout/
  - Use barrel exports (index.ts) for cleaner imports
---

## Iteration 3 - US-003: Implement canvas with pan and zoom
- What was implemented:
  - HTML Canvas element with 2D context, fills container and handles window resize
  - Device pixel ratio (DPR) scaling for crisp rendering on high-DPI displays
  - Mouse wheel zoom centered on cursor position (10% to 500% range)
  - Middle-mouse button drag for panning
  - Space+left-click drag for panning (alternative method)
  - Dot grid pattern that scales with zoom and moves with pan
  - Cursor changes to grab/grabbing during pan operations
- Files changed:
  - src/components/layout/Canvas.tsx (complete rewrite with pan/zoom logic)
  - src/components/layout/Canvas.css (added .canvas class styles)
- Learnings for future iterations:
  - Viewport state: { x, y, zoom } where x/y are pan offsets in canvas coords
  - Canvas uses requestAnimationFrame-compatible draw() callback
  - Use useCallback for handlers to prevent unnecessary re-renders
  - Window keydown/keyup listeners for Space key pan mode
  - Grid offset calculation: (panOffset * zoom) % gridSpacing for seamless tiling
---

## Iteration 4 - US-004: Create Zustand store for canvas state
- What was implemented:
  - Installed Zustand package for state management
  - Created TypeScript interfaces in src/types/canvas.ts for all canvas object types
  - Created Zustand store in src/stores/canvasStore.ts with:
    - State: objects (Map), selectedIds (Set), viewport
    - Actions: addObject, updateObject, deleteObject, setSelection, setViewport
  - All object types extend BaseObject with id, type, x, y, width, height, rotation, opacity
- Files changed:
  - package.json (added zustand dependency)
  - src/types/canvas.ts (created - object type definitions)
  - src/stores/canvasStore.ts (created - Zustand store)
- Learnings for future iterations:
  - Store import: `import { useCanvasStore } from '../stores/canvasStore'`
  - Types import: `import type { CanvasObject, Viewport } from '../types/canvas'`
  - Using Map and Set for objects/selectedIds for O(1) lookups
  - Object types: rectangle, ellipse, text, frame, path, image, video
  - Tool types: select, hand, rectangle, text, frame, pen
---

## Iteration 5 - US-005: Build left toolbar with tool buttons
- What was implemented:
  - Added activeTool state and setActiveTool action to Zustand store
  - Vertical toolbar with 6 tool buttons: Select (V), Hand (H), Rectangle (R), Text (T), Frame (F), Pen (P)
  - Each button has a custom SVG icon
  - Active tool highlighted with accent color (--color-accent: #0066ff)
  - Tooltips on hover showing tool name + keyboard shortcut
  - Divider line after Text tool to separate tool groups
- Files changed:
  - src/stores/canvasStore.ts (added activeTool state and setActiveTool action)
  - src/components/layout/Toolbar.tsx (added tool buttons with icons)
  - src/components/layout/Toolbar.css (added styles for buttons, active state, tooltips, divider)
- Learnings for future iterations:
  - Tool buttons use position: relative with tooltip positioned absolutely to the right
  - Tooltip appears on hover with opacity transition
  - Store state selector: `useCanvasStore((state) => state.activeTool)`
  - setActiveTool can be called with ToolType to switch tools
---

## Iteration 6 - US-006: Implement tool state and keyboard shortcuts
- What was implemented:
  - Created useKeyboardShortcuts hook in src/hooks/useKeyboardShortcuts.ts
  - Global keyboard event listener for tool switching shortcuts
  - Shortcuts: V (select), H (hand), R (rectangle), T (text), F (frame), P (pen)
  - Shortcuts disabled when typing in input fields, textareas, or contenteditable elements
  - Shortcuts also disabled when modifier keys (Ctrl/Meta/Alt) are pressed
  - Wired up hook in App.tsx to enable shortcuts globally
- Files changed:
  - src/hooks/useKeyboardShortcuts.ts (created)
  - src/App.tsx (added hook import and call)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Check target.tagName for INPUT/TEXTAREA and target.isContentEditable to disable shortcuts
  - Use window.addEventListener for global keyboard shortcuts
  - Remember to clean up listeners in useEffect return
---

## Iteration 7 - US-007: Implement selection tool with click-to-select
- What was implemented:
  - Hit testing function to detect clicks on objects (with rotation support)
  - Click on object selects it (updates selectedIds in store)
  - Click on empty canvas deselects all
  - Selection box with 8 resize handles + rotation handle
  - Selection highlight color: blue (#0066ff)
  - Shift+click toggles selection (add/remove from selection)
  - Coordinate conversion helpers: canvasToScreen, screenToCanvas
  - Object rendering for all types: rectangle, ellipse, text, frame, path
- Files changed:
  - src/components/layout/Canvas.tsx (added hitTest, drawObject, drawSelectionBox, selection handling)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Hit testing with rotation: translate point relative to object center, apply inverse rotation, then check bounds
  - Draw selection boxes after objects so they appear on top
  - Handle positions array pattern: corners and edge midpoints for 8 handles
  - Rotation handle: positioned above top-center with connecting line
  - Store selectors: use separate selectors to avoid unnecessary re-renders
---

## Iteration 8 - US-008: Implement selection tool drag-to-move
- What was implemented:
  - Added updateObjects batch action to store for efficient multi-object updates
  - Drag state tracking (isDragging, hoveredObjectId) in Canvas component
  - Drag-to-move for selected objects with real-time position updates
  - Multiple selected objects move together using batch updates
  - Hover detection for move cursor on selected objects
  - Added test objects in App.tsx for development testing
  - Fixed JSX.Element type to use ReactNode in Toolbar
- Files changed:
  - src/stores/canvasStore.ts (added updateObjects batch action)
  - src/components/layout/Canvas.tsx (added drag handling and hover detection)
  - src/components/layout/Toolbar.tsx (fixed JSX.Element type)
  - src/App.tsx (added test objects for development)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use batch updates (updateObjects) for moving multiple objects to avoid re-render overhead
  - Track drag state with refs (lastMousePos, dragStartCanvasPos) to avoid state update lag
  - Movement delta = (screen delta) / zoom for correct canvas coordinate translation
  - Cursor style logic: check isDragging first, then hoveredObjectId for hover state
---

## Iteration 9 - US-009: Implement marquee selection
- What was implemented:
  - Marquee selection state tracking (isMarqueeSelecting, marqueeStart, marqueeEnd refs)
  - Drag on empty canvas draws selection rectangle with dashed blue border and semi-transparent blue fill
  - Objects intersecting marquee rectangle are selected on mouse up (AABB intersection check)
  - Shift+drag adds to existing selection (preserves current selection)
  - Fixed ESLint error: added braces around case 'text' block for lexical declaration
- Files changed:
  - src/components/layout/Canvas.tsx (added marquee selection logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use refs (marqueeStart, marqueeEnd, marqueeShiftKey) for tracking marquee state during drag
  - AABB intersection check: !(obj.x > maxX || objRight < minX || obj.y > maxY || objBottom < minY)
  - Force redraw during marquee drag by calling draw() directly to show marquee rectangle
  - ctx.setLineDash([4, 4]) creates dashed border effect
  - Remember to handle mouseLeave to cancel marquee selection if mouse leaves canvas
---

## Iteration 10 - US-010: Implement resize via selection handles
- What was implemented:
  - HandleType type definition for 8 handle types (nw, n, ne, e, se, s, sw, w)
  - HANDLE_POSITIONS array with position getters for each handle
  - HANDLE_CURSORS map for appropriate resize cursors
  - hitTestHandle function to detect clicks on resize handles with rotation support
  - Resize logic for all 8 handles with proportional/free resize support
  - Corner handles: proportional resize by default, Shift for free resize
  - Edge handles: single dimension resize only
  - Minimum size enforcement (10x10px MIN_OBJECT_SIZE constant)
  - Cursor changes to resize cursors on handle hover
  - State: isResizing, activeResizeHandle, hoveredHandle
  - Refs: resizeHandle, resizeStartObjState, resizeShiftKey
- Files changed:
  - src/components/layout/Canvas.tsx (added resize handle types, hit testing, resize logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use state (activeResizeHandle) instead of ref for cursor style to avoid ESLint ref-during-render errors
  - Handle hit testing: transform click point to object's local coordinate system using inverse rotation
  - Resize proportionally: use aspect ratio and decide which dimension to follow based on larger delta
  - For handles that affect position (nw, n, ne, w, sw), recalculate x/y based on new dimensions
  - Enforce minimum size by clamping dimensions and recalculating position for affected handles
---

## Iteration 11 - US-011: Implement rotation via handle
- What was implemented:
  - RotationHandle type definition ('rotation' | null)
  - hitTestRotationHandle function to detect clicks on rotation handle
  - Rotation state tracking: isRotating, hoveredRotationHandle, rotationStartAngle, rotationObjStartRotation
  - Drag rotation handle rotates object around its center
  - Shift+drag snaps rotation to 15° increments
  - Cursor changes to 'grab' when hovering rotation handle
  - Rotation is calculated using Math.atan2 to get angle from object center to mouse position
- Files changed:
  - src/components/layout/Canvas.tsx (added rotation handle types, hit testing, rotation logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use Math.atan2(dy, dx) to calculate angle from center to mouse position
  - Add +90 offset because rotation handle is at top (not right side like 0° in atan2)
  - Track rotation start angle and object's starting rotation to calculate delta
  - Normalize rotation to 0-360 range: ((rotation % 360) + 360) % 360
  - Snap to increments: Math.round(value / increment) * increment
  - Check rotation handle hit test BEFORE resize handles since rotation handle is above object
---

## Iteration 12 - US-012: Implement rectangle tool
- What was implemented:
  - Rectangle tool drawing functionality in Canvas.tsx
  - State: isDrawingRect to track when user is drawing
  - Refs: rectDrawStart, rectDrawEnd, rectDrawShiftKey for tracking draw state
  - drawRectPreview function to show rectangle preview while drawing
  - On mouse down with rectangle tool: start drawing at click position
  - On mouse move: update preview, Shift constrains to square
  - On mouse up: create rectangle object with default fill (#4a4a4a), add to store
  - Tool automatically switches to Select after drawing
  - Minimum size check (10x10px) before creating rectangle
  - Uses crypto.randomUUID() for generating unique object IDs
- Files changed:
  - src/components/layout/Canvas.tsx (added rectangle tool logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Import RectangleObject type from types/canvas for typed object creation
  - Use refs for tracking draw start/end to avoid state update lag during drag
  - crypto.randomUUID() is built into modern browsers, no need for nanoid
  - Square constraint: Math.max(abs(width), abs(height)) for both dimensions with sign preserved
  - Normalize negative dimensions: x = width >= 0 ? start.x : start.x + width
  - Remember to add isDrawingRect to all relevant dependency arrays
---

## Iteration 13 - US-013: Implement ellipse shape variant
- What was implemented:
  - Alt+Rectangle tool draws ellipse instead of rectangle
  - Ellipse preview shown while drawing when Alt is held
  - Shift constrains to circle (both for preview and final shape)
  - Alt key is tracked during mouse down, move, and up events
  - EllipseObject type imported and used for ellipse creation
- Files changed:
  - src/components/layout/Canvas.tsx (added Alt key tracking and ellipse drawing logic)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use rectDrawAltKey ref to track Alt key state during drawing operation
  - Ellipse rendering uses ctx.ellipse() with center position and radii
  - Alt key can be toggled during drawing to switch between rectangle and ellipse preview
  - EllipseObject type already existed in canvas.ts, rendering was also already implemented
---

## Iteration 14 - US-014: Implement text tool
- What was implemented:
  - Click with Text tool creates text object at click position
  - Text object enters edit mode immediately with focused HTML input overlay
  - Typing updates text content in real-time via updateObject store action
  - Click outside (onBlur), Escape, or Enter exits edit mode
  - Default font: Inter/system-ui/sans-serif, 16px, white (#ffffff)
  - Tool switches to Select after creating text object
- Files changed:
  - src/components/layout/Canvas.tsx (added text tool handling, editingTextId state, text input overlay)
  - src/components/layout/Canvas.css (added .text-edit-input styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use HTML input overlay positioned absolutely over canvas for text editing
  - Calculate screen position using canvasToScreen and apply viewport.zoom to font size
  - Use e.stopPropagation() on text input keydown to prevent tool shortcuts firing
  - TextObject type already defined in canvas.ts with text, fontSize, fontFamily, textAlign
  - onBlur handles click outside, onKeyDown handles Escape/Enter
---

## Iteration 15 - US-015: Implement text editing on existing text
- What was implemented:
  - Double-click detection using lastClickTime and lastClickObjectId refs
  - 300ms threshold for double-click detection on same object
  - Double-click on text object enters edit mode and selects the object
  - Native HTML input handles cursor position tracking via selectionStart/selectionEnd
  - Arrow keys navigate cursor naturally via native input behavior
  - Shift+arrows, Ctrl+A, Home/End, and double-click word selection all work via native input
- Files changed:
  - src/components/layout/Canvas.tsx (added double-click detection refs and handling)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Double-click detection: track lastClickTime and lastClickObjectId, compare with 300ms threshold
  - Native HTML input elements handle cursor and selection naturally - no custom implementation needed
  - Return early from handleMouseDown after entering text edit mode to prevent starting drag
  - stopPropagation in handleTextKeyDown prevents tool shortcuts but allows native input behaviors
---

## Iteration 16 - US-016: Implement frame tool
- What was implemented:
  - Frame tool drawing functionality - drag on canvas creates frame object
  - Frame preview while drawing (showing background, border, and "Frame" label)
  - Frame object with subtle background (#2a2a2a) and border (#3a3a3a)
  - Frame label showing name above the frame
  - Frame name editable via double-click (similar to text editing)
  - Frame name input overlay positioned above frame
  - Cursor changes to crosshair when frame tool is active
- Files changed:
  - src/components/layout/Canvas.tsx (added frame drawing, preview, name editing)
  - src/components/layout/Canvas.css (added .frame-name-input styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Frame tool follows same pattern as rectangle tool for drawing
  - FrameObject type already existed in canvas.ts with name property
  - Frame rendering was already implemented in drawObject, just needed drawing logic
  - Double-click detection pattern reused from text editing for frame name editing
  - Input overlay positioned using top offset to appear above frame (top - fontSize - 4px)
---

## Iteration 17 - US-017: Implement pen tool for freehand drawing
- What was implemented:
  - Pen tool drawing functionality - drag creates path from mouse movement
  - State tracking: isDrawingPath (boolean), pathDrawPoints (ref to PathPoint[])
  - Mouse down with pen tool starts path with first point
  - Mouse move adds points to the path array while drawing
  - Mouse up finalizes path: calculates bounding box, normalizes points relative to top-left
  - drawPathPreview function renders path during drawing
  - Default stroke: white (#ffffff), 2px, round line caps and joins
  - Tool automatically switches to select after drawing
  - Crosshair cursor shown when pen tool is active
- Files changed:
  - src/components/layout/Canvas.tsx (added pen tool handling, path preview, state management)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - PathObject and PathPoint types already existed in canvas.ts
  - Path rendering was already implemented in drawObject, just needed drawing logic
  - Pattern: collect points relative to canvas, then normalize to bounding box on finalize
  - Path bounding box calculated by finding min/max x/y of all points
  - Points normalized by subtracting minX/minY from each point
  - Path object stores normalized points (relative to object's x,y position)
---

## Iteration 18 - US-018: Build properties panel structure
- What was implemented:
  - Panel header with "PROPERTIES" title and settings gear icon
  - CollapsibleSection component for reusable section pattern
  - PropertyRow component for label/value display
  - Transform section: X-POS, Y-POS, WIDTH, HEIGHT, ROTATION
  - Appearance section: OPACITY, FILL, STROKE
  - Hierarchy section: item count and object list with type icons
  - Empty state: shows "---" for all values when nothing selected
  - Hierarchy items highlight when selected
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (complete rewrite with sections)
  - src/components/layout/PropertiesPanel.css (added styles for all new elements)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - CollapsibleSection pattern: internal state for isOpen, toggle button, conditional content render
  - getDisplayValue pattern: function that checks selection state and calls getter only if valid
  - Hierarchy icons: use Unicode symbols (▢, ○, T, ⬚, ✎) for quick type identification
  - Type narrowing with 'text' in obj pattern for accessing type-specific properties
  - Next tasks (US-019 to US-024) will need editable inputs instead of read-only PropertyRow
---

## Iteration 19 - US-019: Implement transform section (position)
- What was implemented:
  - EditablePropertyRow component for editable numeric inputs
  - X-POS and Y-POS input fields that show current object position
  - Click to edit, Enter commits, Escape reverts
  - Values sync with canvas when object is moved
  - getMultiSelectValue function: shows "---" when multiple objects have different values
  - CSS styles for editable inputs with hover state
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added EditablePropertyRow, getMultiSelectValue, updateObject usage)
  - src/components/layout/PropertiesPanel.css (added .property-value.editable and .property-input styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - EditablePropertyRow pattern: useState for isEditing/editValue, useRef for input/originalValue
  - Track originalValue on edit start to support Escape revert
  - Use useEffect to sync editValue with prop when not editing
  - stopPropagation on keydown to prevent tool shortcuts from firing
  - getMultiSelectValue checks if all selected objects have same value
---

## Iteration 20 - US-020: Implement transform section (size)
- What was implemented:
  - Editable WIDTH and HEIGHT input fields in the Transform section
  - Values update when object is selected and sync with canvas
  - Typing in field updates object size (Enter commits, Escape reverts)
  - Constrain proportions toggle (chain link icon) that maintains aspect ratio
  - When constrain is ON: changing width proportionally updates height (and vice versa)
  - Fixed ESLint error by removing useEffect-based value sync
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added size-row wrapper, constrain toggle, updated WIDTH/HEIGHT to EditablePropertyRow)
  - src/components/layout/PropertiesPanel.css (added .size-row and .constrain-toggle styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Don't use useEffect to sync editValue with prop - just display prop value directly when not editing
  - Don't use refs during render - ESLint will error on prevValueRef.current comparisons
  - Constrain proportions pattern: calculate aspect ratio from current dimensions, multiply new value by ratio
  - SVG chain link icon: use paths for half-loops and optional connecting line for "linked" state
---

## Iteration 21 - US-021: Implement transform section (rotation)
- What was implemented:
  - RotationControl component with editable degree input field
  - Circular dial/slider for visual rotation adjustment
  - Value shows degrees (0-360) with normalization
  - Dragging dial rotates object in real-time
  - Click to edit input, Enter commits, Escape reverts
  - Shows "---" when nothing selected (disabled state)
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added RotationControl component with useCallback)
  - src/components/layout/PropertiesPanel.css (added .rotation-control, .rotation-dial styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Rotation dial: use atan2 to calculate angle from center to mouse, add 90 to offset 0° to top
  - Handle angle wrapping: if delta > 180, subtract 360; if < -180, add 360
  - Track dragStartAngle and dragStartValue to calculate delta rotation
  - Use window event listeners for mousemove/mouseup during drag
  - transform-origin: bottom center for rotating indicator from center
---

## Iteration 22 - US-022: Implement appearance section (opacity)
- What was implemented:
  - OpacityControl component with editable percentage input (0-100%)
  - Horizontal slider for visual opacity adjustment
  - Dragging slider updates object opacity in real-time
  - Click to edit input, Enter commits, Escape reverts
  - Clamps values to 0-100 range
  - Shows "---" when nothing selected (disabled state)
- Files changed:
  - src/components/layout/PropertiesPanel.tsx (added OpacityControl component)
  - src/components/layout/PropertiesPanel.css (added .opacity-control and .opacity-slider styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Slider pattern: track + fill + handle, calculate percentage from mouse X position
  - Opacity stored as 0-1 internally but displayed as 0-100%
  - Use getOpacityFromMouse with getBoundingClientRect for position calculation
  - Similar pattern to RotationControl but with linear slider instead of circular dial
  - Disable transitions during drag for instant feedback
---
